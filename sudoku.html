<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>for some reason</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="assets/css/sudoku.css" rel="stylesheet" />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }

      .sudoku-cell {
        width: 11.11%;
        padding-bottom: 11.11%;
        position: relative;
        border: 1px solid #d1d5db;
        transition: background-color 0.2s;
        cursor: pointer;
      }

      .sudoku-cell.highlighted {
        background-color: #fef08a; /* yellow-200*/
      }

      .sudoku-cell.selected {
        /* A strong blue outline to ensure visibility on top of any cell color */
        outline: 3px solid #2563eb; /* blue-600 */
        outline-offset: -3px;
        z-index: 5; /* Ensures the outline renders above adjacent cell borders */
      }

      .sudoku-cell .cell-content {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.75rem;
      }

      .sudoku-cell .user-value {
        color: #3b82f6;
      } /* blue-500 */
      .sudoku-cell .given-value {
        color: #1f2937;
        font-weight: 600;
      } /* gray-800 */
      .sudoku-cell.invalid .user-value {
        background-color: #fecaca;
      } /* red-200 */

      .pencil-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        width: 100%;
        height: 100%;
        font-size: 0.7rem;
        color: #6b7280; /* gray-500 */
        text-align: center;
        line-height: 1.2;
      }

      .pencil-mark {
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }

      /* Thicker borders for the 3x3 subgrids */
      .sudoku-grid .grid-row .sudoku-cell:nth-child(3),
      .sudoku-grid .grid-row .sudoku-cell:nth-child(6) {
        border-right-width: 3px;
        border-right-color: #374151;
      }
      .sudoku-grid .grid-row:nth-child(3),
      .sudoku-grid .grid-row:nth-child(6) {
        border-bottom-width: 3px;
        border-bottom-color: #374151;
      }

      .control-btn.active {
        background-color: #1d4ed8; /* blue-700 */
        color: white;
        border-color: #1d4ed8;
      }

      .color-btn.selected {
        outline: 2px solid #1d4ed8;
        outline-offset: 2px;
      }

      #candidate-modal {
        background-color: rgba(0, 0, 0, 0.5);
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: #d1d5db; /* gray-300 */
        color: #6b7280; /* gray-500 */
        border-color: #d1d5db;
      }
      button:disabled:hover {
        background-color: #d1d5db;
      }

      /* Solve Animation */
      @keyframes cell-solve-animation {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
          /* background-color: #a7f3d0; */
        }
      }

      .is-solved .sudoku-cell {
        background-color: #a7f3d0 !important;
        animation: cell-solve-animation 1s ease-in-out;
        animation-delay: calc((var(--row) * 9 + var(--col)) * 20ms);
      }
    </style>
  </head>
  <body
    class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg w-full max-w-xl">
      <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">
        fsrs Daily Irred. Sudoku
      </h1>

      <div class="mb-2 flex items-center justify-between gap-4 flex-wrap">
        <div class="flex items-center gap-2">
          <label for="date-select" class="text-sm font-medium">Date</label>
          <select
            id="date-select"
            class="block p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
          ></select>
        </div>

        <div class="flex items-center gap-2">
          <label for="level-select" class="text-sm font-medium">Level</label>
          <select
            id="level-select"
            class="block p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
          ></select>
        </div>
      </div>

      <div
        id="message-area"
        class="text-center mb-2 text-sm font-semibold min-h-10"
      ></div>

      <div class="mt-4 grid grid-cols-2 sm:grid-cols-3 gap-3"></div>

      <div
        id="sudoku-grid"
        class="sudoku-grid grid grid-cols-1 w-full border-2 border-gray-700"
      ></div>

      <div
        id="puzzle-info"
        class="flex justify-between text-sm text-gray-600 mt-2 px-1 font-semibold"
      >
        <span id="puzzle-level"></span>
        <span id="puzzle-timer"></span>
        <span id="puzzle-score"></span>
      </div>

      <div class="mt-2">
        <div class="flex justify-center space-x-2 mb-2" id="mode-selector">
          <button
            id="mode-toggle-btn"
            class="control-btn active px-4 py-2 text-sm font-semibold border border-gray-300 rounded-md shadow-sm"
          >
            Number (Z)
          </button>
          <button
            data-mode="color"
            class="control-btn px-4 py-2 text-sm font-semibold border border-gray-300 rounded-md shadow-sm"
          >
            Color (X)
          </button>
          <button
            id="format-toggle-btn"
            class="control-btn px-4 py-2 text-sm font-semibold border border-gray-300 dark:border-gray-500 dark:text-gray-200 rounded-md shadow-sm"
          >
            Dspl. A (D)
          </button>
        </div>
        <div class="grid grid-cols-9 gap-1" id="number-pad"></div>
      </div>
      <div class="mt-2 grid grid-cols-2 sm:grid-cols-3 gap-3">
        <button
          id="undo-btn"
          class="w-full inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50"
        >
          Undo (Ctrl+Z)
        </button>
        <button
          id="redo-btn"
          class="w-full inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50"
        >
          Redo (Ctrl+Y)
        </button>
        <button
          id="auto-pencil-btn"
          class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700"
        >
          Auto-Pencil (A)
        </button>
        <button
          id="solve-btn"
          class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700"
        >
          Solve (S)
        </button>

        <button
          id="clear-btn"
          class="w-full inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50"
        >
          Quick Restart (Q)
        </button>
        <button
          id="clear-colors-btn"
          class="w-full inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50"
        >
          Wipe Colors (W)
        </button>
      </div>
      <div id="solver-link-container" class="text-center mt-2"></div>
      <div class="mt-2">
        <div class="mt-1 flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            id="puzzle-string"
            class="flex-grow shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md p-2"
            placeholder="Enter 81 characters..."
          />
          <button
            id="load-btn"
            class="w-full sm:w-auto inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700"
          >
            Load
          </button>
        </div>
      </div>
    </div>

    <div
      id="date-modal"
      class="fixed inset-0 z-20 hidden items-center justify-center bg-black bg-opacity-50"
    >
      <div class="bg-white p-6 rounded-lg shadow-xl w-80">
        <h3 class="text-lg font-medium text-center mb-2">
          Enter a Date (2025-09-12 - )
        </h3>
        <input
          type="text"
          id="date-input"
          maxlength="10"
          inputmode="numeric"
          pattern="\d*"
          placeholder="YYYY-MM-DD"
          class="w-full border p-2 rounded-md text-center mb-2"
        />
        <div
          id="date-error"
          class="text-red-600 text-sm font-semibold h-5 mb-2 text-center"
        ></div>
        <div class="flex justify-between">
          <button
            id="date-cancel-btn"
            class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300"
          >
            Cancel
          </button>
          <button
            id="date-submit-btn"
            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Submit
          </button>
        </div>
      </div>
    </div>

    <div
      id="candidate-modal"
      class="fixed inset-0 z-10 hidden items-center justify-center"
    >
      <div class="bg-white p-6 rounded-lg shadow-xl">
        <h3 class="text-lg font-medium text-center mb-2">Color a Candidate</h3>
        <div id="candidate-grid" class="grid grid-cols-3 gap-2"></div>
        <button
          id="close-modal-btn"
          class="mt-2 w-full px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300"
        >
          Close
        </button>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const gridContainer = document.getElementById("sudoku-grid");
        const puzzleStringInput = document.getElementById("puzzle-string");
        const loadBtn = document.getElementById("load-btn");
        const solveBtn = document.getElementById("solve-btn");
        const clearBtn = document.getElementById("clear-btn");
        const clearColorsBtn = document.getElementById("clear-colors-btn");
        const autoPencilBtn = document.getElementById("auto-pencil-btn");
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");
        const messageArea = document.getElementById("message-area");
        const modeSelector = document.getElementById("mode-selector");
        const numberPad = document.getElementById("number-pad");
        const candidateModal = document.getElementById("candidate-modal");
        const candidateGrid = document.getElementById("candidate-grid");
        const closeModalBtn = document.getElementById("close-modal-btn");
        const formatToggleBtn = document.getElementById("format-toggle-btn");
        const dateSelect = document.getElementById("date-select");
        const levelSelect = document.getElementById("level-select");
        const puzzleInfoContainer = document.getElementById("puzzle-info");
        const puzzleLevelEl = document.getElementById("puzzle-level");
        const puzzleScoreEl = document.getElementById("puzzle-score");
        const puzzleTimerEl = document.getElementById("puzzle-timer");
        const modeToggleButton = document.getElementById("mode-toggle-btn");
        const colorButton = modeSelector.querySelector('[data-mode="color"]');

        const difficultyWords = [
          "ROOKIE",
          "LAYMAN",
          "AMATEUR",
          "TECHNICIAN",
          "WIZARD",
          "EXPERT",
          "MASTER",
          "NEMESIS",
          "DOMINATOR",
          "VANQUISHER",
        ];

        const colorPalette = [
          "#f87171",
          "#fb923c",
          "#facc15",
          "#a3e635",
          "#34d399",
          "#22d3ee",
          "#60a5fa",
          "#c084fc",
          "#f472b6",
        ];

        const levelTips = [
          "Lv. 0: Singles",
          "Lv. 1: Locked Pair, Locked Triple",
          "Lv. 2: Intersections, Pairs, Triples",
          "Lv. 3: Quads, X-Wing, XY-Wing, Remote Pair",
          "Lv. 4: Unique Rectangles, BUG+1, XYZ-Wing, W-Wing, Swordfish, Jellyfish",
          "Lv. 5: Hidden Rectangles, BUG Lite (6 cells), (Grouped) Turbot-Fishes",
          "Lv. 6: WXYZ-Wing, Finned Fishes, X-Chain, Firework, Sue de Coq",
          "Lv. 7: Grouped X-Chain, 3D Medusa, Alternating Inference Chain",
          "Lv. 8: Grouped AIC, Pair Subset Exclusion, ALS-XZ",
          "Lv. 9: Triple Sub. Excl., ALS-XY/W-Wing, Finned Franken/Mutant Swordfish",
        ];

        let boardState = [];
        let allPuzzles = [];
        let selectedCell = { row: null, col: null };
        let currentMode = "concrete";
        let coloringSubMode = "cell";
        let candidatePopupFormat = "A"; // 'A' for numpad, 'B' for phone pad
        let selectedColor = null;
        let highlightedDigit = null;
        let highlightState = 0; // 0: off, 1: digit, 2: bi-value
        let history = [];
        let historyIndex = -1;
        let timerInterval = null;
        let startTime = 0;

        function addSudokuCoachLink(puzzleString) {
          const container = document.getElementById("solver-link-container");
          if (!container) return;

          // Clear any previous link
          container.innerHTML = "";
          if (!puzzleString) return; // Don't add a link if the puzzle string is empty

          // Convert '.' to '0' for the URL
          const puzzleForLink = puzzleString.replace(/\./g, "0");
          const solverUrl = `https://sudoku.coach/en/solver/${puzzleForLink}`;

          // Create the link element
          const link = document.createElement("a");
          link.href = solverUrl;
          link.target = "_blank"; // Opens in a new tab
          link.rel = "noopener noreferrer"; // Security best practice
          link.textContent = "Export to Sudoku Coach Solver (E)";

          // Apply the new button styling
          link.className =
            "w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-orange-500 hover:bg-orang-600";

          container.appendChild(link);
        }

        async function initialize() {
          createGrid();
          updateControls();
          initBoardState();
          setupEventListeners();

          try {
            const response = await fetch("sudoku.json");
            if (!response.ok) throw new Error("Failed to load sudoku.json");
            allPuzzles = await response.json();
            populateSelectors();
            findAndLoadSelectedPuzzle();
          } catch (error) {
            console.error("Error loading puzzles:", error);
          }
        }

        function populateSelectors() {
          // Populate Level selector (0-9)
          levelSelect.innerHTML = "";
          for (let i = 0; i < 10; i++) {
            const option = document.createElement("option");
            option.value = i;
            // Format the text to include both number and word
            option.textContent = `${i} (${difficultyWords[i]})`;
            levelSelect.appendChild(option);
          }

          // Populate Date selector (last 7 days including today, but not before 20250912)
          dateSelect.innerHTML = "";

          const today = new Date();
          const minDateNum = 20250912;

          const recentDates = [];

          for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() - i);

            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, "0");
            const dd = String(date.getDate()).padStart(2, "0");

            const dateNum = parseInt(`${yyyy}${mm}${dd}`);

            if (dateNum >= minDateNum) {
              recentDates.push({
                dateNum,
                label:
                  i === 0
                    ? "Today"
                    : i === 1
                    ? "Yesterday"
                    : `${yyyy}-${mm}-${dd}`,
              });
            }
          }

          // Ensure descending order
          recentDates.sort((a, b) => b.dateNum - a.dateNum);

          recentDates.forEach(({ dateNum, label }) => {
            const option = document.createElement("option");
            option.value = dateNum;
            option.textContent = label;
            dateSelect.appendChild(option);
          });

          const customOption = document.createElement("option");
          customOption.value = "custom";
          customOption.textContent = "Enter a date";
          dateSelect.appendChild(customOption);
        }

        function findAndLoadSelectedPuzzle() {
          const selectedDate = parseInt(dateSelect.value, 10);
          const selectedLevel = parseInt(levelSelect.value, 10);

          const puzzle = allPuzzles.find(
            (p) => p.date === selectedDate && p.level === selectedLevel
          );

          if (puzzle) {
            puzzleStringInput.value = puzzle.puzzle;
            loadPuzzle(puzzle.puzzle, puzzle);
            showMessage(
              `Loaded puzzle for ${
                dateSelect.options[dateSelect.selectedIndex].text
              }, Level ${selectedLevel}`,
              "green"
            );
            setTimeout(() => {
              const tip = levelTips[selectedLevel];
              if (tip) {
                showMessage(tip, "gray");
              }
            }, 1500);
          } else {
            initBoardState();
            renderBoard();
            showMessage("No puzzle found for this date and level.", "red");
            puzzleLevelEl.textContent = "";
            puzzleScoreEl.textContent = "";
            puzzleTimerEl.textContent = "";
            stopTimer();
            addSudokuCoachLink(null);
          }
        }

        function initBoardState() {
          boardState = Array(9)
            .fill(null)
            .map(() =>
              Array(9)
                .fill(null)
                .map(() => ({
                  value: 0,
                  isGiven: false,
                  pencils: new Set(),
                  cellColor: null,
                  pencilColors: new Map(),
                }))
            );
        }

        function createGrid() {
          gridContainer.innerHTML = "";
          for (let i = 0; i < 9; i++) {
            const rowEl = document.createElement("div");
            rowEl.className = "grid-row flex";
            for (let j = 0; j < 9; j++) {
              const cellEl = document.createElement("div");
              cellEl.className = "sudoku-cell";
              cellEl.dataset.row = i;
              cellEl.dataset.col = j;
              rowEl.appendChild(cellEl);
            }
            gridContainer.appendChild(rowEl);
          }
        }

        function updateControls() {
          numberPad.innerHTML = "";
          if (currentMode === "color") {
            for (let i = 0; i < 9; i++) {
              const btn = document.createElement("button");
              btn.style.backgroundColor = colorPalette[i];
              btn.dataset.color = colorPalette[i];

              // 1. Add the number (1-9) as the button's text
              btn.textContent = i + 1;

              // 2. Add a class to make the text dim and readable
              btn.className =
                "color-btn p-2 text-lg font-bold border rounded-md shadow-sm h-12 text-white/50";

              numberPad.appendChild(btn);
            }
          } else {
            for (let i = 1; i <= 9; i++) {
              const btn = document.createElement("button");
              btn.textContent = i;
              btn.dataset.number = i;
              btn.className =
                "p-2 text-lg font-bold border rounded-md shadow-sm hover:bg-gray-100 h-12";
              numberPad.appendChild(btn);
            }
          }
        }

        function renderBoard() {
          const cells = gridContainer.querySelectorAll(".sudoku-cell");
          cells.forEach((cell) => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const state = boardState[row][col];

            cell.innerHTML = "";
            cell.classList.remove("selected", "invalid", "highlighted");
            cell.style.backgroundColor = state.cellColor || "";

            if (row === selectedCell.row && col === selectedCell.col) {
              cell.classList.add("selected");
            }

            const content = document.createElement("div");
            content.className = "cell-content";

            if (state.value !== 0) {
              content.textContent = state.value;
              content.classList.add(
                state.isGiven ? "given-value" : "user-value"
              );
            } else if (state.pencils.size > 0) {
              const pencilGrid = document.createElement("div");
              pencilGrid.className = "pencil-grid";

              const orderA = [1, 2, 3, 4, 5, 6, 7, 8, 9];
              const orderB = [7, 8, 9, 4, 5, 6, 1, 2, 3];
              const currentOrder =
                candidatePopupFormat === "A" ? orderA : orderB;

              currentOrder.forEach((i) => {
                const mark = document.createElement("div");
                mark.className = "pencil-mark";
                if (state.pencils.has(i)) {
                  mark.textContent = i;
                  if (state.pencilColors.has(i)) {
                    mark.style.color = state.pencilColors.get(i);
                  }
                }
                pencilGrid.appendChild(mark);
              });
              content.appendChild(pencilGrid);
            }
            cell.appendChild(content);

            // Apply highlight if a digit is selected for highlighting
            if (highlightState === 1 && highlightedDigit !== null) {
              if (
                state.value === highlightedDigit ||
                (state.value === 0 && state.pencils.has(highlightedDigit))
              ) {
                cell.classList.add("highlighted");
              }
            } else if (highlightState === 2) {
              if (state.value === 0 && state.pencils.size === 2) {
                cell.classList.add("highlighted");
              }
            }
          });
          validateBoard();
        }

        function isValidDate(yyyymmdd) {
          if (!/^\d{8}$/.test(yyyymmdd)) return false;

          const year = parseInt(yyyymmdd.slice(0, 4), 10);
          const month = parseInt(yyyymmdd.slice(4, 6), 10);
          const day = parseInt(yyyymmdd.slice(6, 8), 10);

          // Month 1–12, Day 1–31
          if (month < 1 || month > 12) return false;
          if (day < 1 || day > 31) return false;

          // Construct real JS Date
          const d = new Date(year, month - 1, day);
          return (
            d.getFullYear() === year &&
            d.getMonth() === month - 1 &&
            d.getDate() === day
          );
        }

        function setupEventListeners() {
          gridContainer.addEventListener("click", handleCellClick);
          modeSelector.addEventListener("click", handleModeChange);
          numberPad.addEventListener("click", handleNumberPadClick);
          loadBtn.addEventListener("click", () =>
            loadPuzzle(puzzleStringInput.value)
          );
          solveBtn.addEventListener("click", solve);
          clearBtn.addEventListener("click", clearUserBoard);
          clearColorsBtn.addEventListener("click", clearAllColors);
          autoPencilBtn.addEventListener("click", autoPencil);
          undoBtn.addEventListener("click", undo);
          redoBtn.addEventListener("click", redo);
          closeModalBtn.addEventListener("click", () =>
            candidateModal.classList.add("hidden")
          );
          formatToggleBtn.addEventListener("click", () => {
            candidatePopupFormat = candidatePopupFormat === "A" ? "B" : "A";
            formatToggleBtn.textContent = `Dspl. ${candidatePopupFormat} (D)`;
            renderBoard(); // Re-render the main board to update pencil marks
            // If the popup is open, re-render it too
            if (
              !candidateModal.classList.contains("hidden") &&
              selectedCell.row !== null
            ) {
              showCandidatePopup(selectedCell.row, selectedCell.col);
            }
          });
          dateSelect.addEventListener("change", () => {
            if (dateSelect.value === "custom") {
              // open popup, do nothing to board yet
              dateModal.classList.remove("hidden");
              dateModal.classList.add("flex");
              dateInput.value = "";
              dateError.textContent = "";
              dateInput.focus();
            } else {
              // only renew when a real date is chosen
              findAndLoadSelectedPuzzle();
            }
          });
          levelSelect.addEventListener("change", findAndLoadSelectedPuzzle);
          document.addEventListener("keydown", handleKeyPress);
          // Hover effects for mode buttons
          modeToggleButton.addEventListener("mouseenter", () => {
            if (currentMode === "concrete")
              modeToggleButton.textContent = "Pencil?";
            else if (currentMode === "pencil")
              modeToggleButton.textContent = "Number?";
          });
          modeToggleButton.addEventListener("mouseleave", () => {
            if (currentMode === "concrete")
              modeToggleButton.textContent = "Number";
            else if (currentMode === "pencil")
              modeToggleButton.textContent = "Pencil";
          });

          colorButton.addEventListener("mouseenter", () => {
            if (currentMode === "color") {
              if (coloringSubMode === "cell")
                colorButton.textContent = "Color: Cand?";
              else colorButton.textContent = "Color: Cell?";
            }
          });
          colorButton.addEventListener("mouseleave", () => {
            if (currentMode === "color") {
              if (coloringSubMode === "cell")
                colorButton.textContent = "Color: Cell";
              else colorButton.textContent = "Color: Cand.";
            }
          });
          // Date modal elements
          const dateModal = document.getElementById("date-modal");
          const dateInput = document.getElementById("date-input");
          const dateError = document.getElementById("date-error");
          const dateSubmitBtn = document.getElementById("date-submit-btn");
          const dateCancelBtn = document.getElementById("date-cancel-btn");

          // Keydown events for popup
          dateInput.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              e.preventDefault();
              dateModal.classList.add("hidden");
              dateModal.classList.remove("flex");
              dateSelect.value = dateSelect.querySelector("option").value; // reset selection
            }
            if (e.key === "Enter") {
              e.preventDefault();
              dateSubmitBtn.click(); // trigger submit
            }
            if (e.key === "Backspace") {
              const pos = dateInput.selectionStart;
              if (pos && (pos === 5 || pos === 8)) {
                // skip over the dash
                dateInput.setSelectionRange(pos - 1, pos - 1);
              }
            }
          });

          dateInput.addEventListener("input", () => {
            // keep only digits
            let val = dateInput.value.replace(/\D/g, "");
            if (val.length > 8) val = val.slice(0, 8);

            // build YYYY-MM-DD
            let formatted = "";
            if (val.length > 0) formatted = val.slice(0, 4);
            if (val.length > 4) formatted += "-" + val.slice(4, 6);
            if (val.length > 6) formatted += "-" + val.slice(6, 8);

            dateInput.value = formatted;
          });

          dateSelect.addEventListener("change", () => {
            if (dateSelect.value === "custom") {
              dateModal.classList.remove("hidden");
              dateModal.classList.add("flex");
              dateInput.value = "";
              dateError.textContent = "";
              dateInput.focus();
              return;
            }
            findAndLoadSelectedPuzzle();
          });

          dateSubmitBtn.addEventListener("click", () => {
            const rawValue = dateInput.value.replace(/\D/g, ""); // remove "-"
            if (!isValidDate(rawValue)) {
              dateError.textContent =
                "Please enter a valid calendar date (YYYY-MM-DD).";
              return;
            }

            const dateNum = parseInt(rawValue, 10);
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, "0");
            const dd = String(today.getDate()).padStart(2, "0");
            const todayNum = parseInt(`${yyyy}${mm}${dd}`);

            if (dateNum < 20250912 || dateNum > todayNum) {
              dateError.textContent = `Date must be between 2025-09-12 and ${todayNum}.`;
              return;
            }

            // Success → add option if not exists
            let customOption = [...dateSelect.options].find(
              (opt) => opt.value === rawValue
            );
            if (!customOption) {
              customOption = document.createElement("option");
              customOption.value = rawValue;
              customOption.textContent = `${rawValue.slice(
                0,
                4
              )}-${rawValue.slice(4, 6)}-${rawValue.slice(6, 8)}`;
              dateSelect.appendChild(customOption);
            }

            dateSelect.value = rawValue;
            // Close popup
            dateModal.classList.add("hidden");
            dateModal.classList.remove("flex");
            findAndLoadSelectedPuzzle();
          });

          dateCancelBtn.addEventListener("click", () => {
            dateModal.classList.add("hidden");
            dateModal.classList.remove("flex");
            dateSelect.value = dateSelect.querySelector("option").value; // reset to first valid option
          });
        }

        function handleKeyPress(e) {
          const key = e.key;
          const key_lower = e.key.toLowerCase();
          const isCtrlOrCmd = e.ctrlKey || e.metaKey;

          // --- New Undo/Redo Handling ---
          // Handle these combinations first and stop further execution.
          if (isCtrlOrCmd && key_lower === "z") {
            e.preventDefault();
            undo();
            return; // Exit the function to prevent collision
          }
          if (isCtrlOrCmd && key_lower === "y") {
            e.preventDefault();
            redo();
            return; // Exit the function
          }
          // --- End of New Logic ---

          // Do not trigger shortcuts if typing in an input field
          if (document.activeElement.tagName === "INPUT") {
            return;
          }

          // Close modal with Escape key
          if (
            key === "Escape" &&
            !candidateModal.classList.contains("hidden")
          ) {
            candidateModal.classList.add("hidden");
            return;
          }

          // Priority 1: Candidate Modal is open
          if (!candidateModal.classList.contains("hidden")) {
            if (key >= "1" && key <= "9") {
              const candidateButtons = candidateGrid.querySelectorAll("button");
              let targetButton = null;
              candidateButtons.forEach((btn) => {
                if (btn.textContent === key) {
                  targetButton = btn;
                }
              });

              if (targetButton && !targetButton.disabled) {
                targetButton.click();
              }
            }
            return; // Stop further processing if modal is open
          }

          // Handle Arrow Keys for navigation
          if (key.startsWith("Arrow")) {
            e.preventDefault(); // Prevent page scrolling
            let { row, col } = selectedCell;

            if (row === null || col === null) {
              // If no cell is selected, start at the top-left
              selectedCell = { row: 0, col: 0 };
            } else {
              if (key === "ArrowUp") {
                selectedCell.row = (row - 1 + 9) % 9;
              } else if (key === "ArrowDown") {
                selectedCell.row = (row + 1) % 9;
              } else if (key === "ArrowLeft") {
                selectedCell.col = (col - 1 + 9) % 9;
              } else if (key === "ArrowRight") {
                selectedCell.col = (col + 1) % 9;
              }
            }
            renderBoard();
            return;
          }

          if (key === "Enter") {
            if (selectedCell.row !== null) {
              const cellState = boardState[selectedCell.row][selectedCell.col];
              if (highlightState === 0 && cellState.pencils.size === 2) {
                highlightedDigit = null;
                highlightState = 2;
              } else if (cellState.value !== 0) {
                if (highlightedDigit !== cellState.value) {
                  highlightedDigit = cellState.value;
                  highlightState = 1;
                } else {
                  highlightedDigit = null;
                  highlightState = 0;
                }
              }
              renderBoard();
            }
            return;
          }

          if (key === "Shift") {
            highlightedDigit = null;
            highlightState = 0;
            renderBoard();
            return;
          }

          // Handle Delete/Backspace to clear cell
          if (key === "Delete" || key === "Backspace") {
            e.preventDefault(); // Prevent browser back navigation on backspace
            if (selectedCell.row !== null) {
              const { row, col } = selectedCell;
              const cellState = boardState[row][col];
              if (
                !cellState.isGiven &&
                (cellState.value !== 0 || cellState.pencils.size > 0)
              ) {
                cellState.value = 0;
                cellState.pencils.clear();
                saveState();
                renderBoard();
              }
            }
            return;
          }

          // Handle Mode Toggle Keys
          if (key_lower === "z") {
            modeToggleButton.click();
            return;
          }
          if (key_lower === "x") {
            colorButton.click();
            return;
          }

          if (key_lower === "c") {
            if (
              currentMode === "color" &&
              selectedCell.row !== null &&
              selectedColor !== null
            ) {
              if (coloringSubMode === "cell") {
                const { row, col } = selectedCell;
                const cellState = boardState[row][col];
                const oldColor = cellState.cellColor;
                const newColor =
                  oldColor === selectedColor ? null : selectedColor;
                if (oldColor !== newColor) {
                  cellState.cellColor = newColor;
                  saveState();
                }
              } else {
                // candidate mode
                showCandidatePopup(selectedCell.row, selectedCell.col);
              }
              renderBoard();
            }
            return;
          }

          if (key_lower === "d") {
            formatToggleBtn.click();
            return;
          }

          // Handle Action Keys
          if (key_lower === "a") {
            autoPencilBtn.click();
            return;
          }
          if (key_lower === "s") {
            solveBtn.click();
            return;
          }
          if (key_lower === "e") {
            // Find the solver button (which is an <a> tag) inside its container
            const solverButton = document.querySelector(
              "#solver-link-container a"
            );

            // If the button exists, click it
            if (solverButton) {
              solverButton.click();
            }
            return;
          }
          if (key_lower === "q") {
            clearBtn.click();
            return;
          }
          if (key_lower === "w") {
            clearColorsBtn.click();
            return;
          }

          // Priority 2: Not modal, handle number keys based on current mode
          if (key >= "1" && key <= "9") {
            if (currentMode === "color") {
              const colorButtons = numberPad.querySelectorAll("button");
              const colorIndex = parseInt(key) - 1;
              if (colorButtons[colorIndex]) {
                colorButtons[colorIndex].click();
              }
            } else if (currentMode === "concrete" || currentMode === "pencil") {
              if (selectedCell.row === null) return;
              const numPadButton = numberPad.querySelector(
                `button[data-number="${key}"]`
              );
              if (numPadButton) {
                numPadButton.click();
              }
            }
          }
        }

        function handleCellClick(e) {
          const cell = e.target.closest(".sudoku-cell");

          selectedCell.row = parseInt(cell.dataset.row);
          selectedCell.col = parseInt(cell.dataset.col);
          const cellState = boardState[selectedCell.row][selectedCell.col];

          if (currentMode === "color") {
            if (coloringSubMode === "cell") {
              const oldColor = cellState.cellColor;
              const newColor =
                oldColor === selectedColor ? null : selectedColor;
              if (oldColor !== newColor) {
                cellState.cellColor = newColor;
                saveState();
              }
            } else {
              // candidate mode
              showCandidatePopup(selectedCell.row, selectedCell.col);
            }
          } else {
            // --- Revised Highlight Logic ---

            if (highlightState === 0 && cellState.pencils.size === 2) {
              highlightedDigit = null;
              highlightState = 2;
            } else if (cellState.value !== 0) {
              if (highlightedDigit !== cellState.value) {
                highlightedDigit = cellState.value;
                highlightState = 1;
              } else {
                highlightedDigit = null;
                highlightState = 0;
              }
            }
          }
          renderBoard();
          return;
        }

        function handleModeChange(e) {
          const clickedButton = e.target.closest("button");
          if (!clickedButton) return;

          const previousMode = currentMode;

          // --- State Update Logic ---
          if (clickedButton === modeToggleButton) {
            currentMode =
              currentMode === "concrete" || currentMode === "pencil"
                ? currentMode === "concrete"
                  ? "pencil"
                  : "concrete"
                : "concrete";
          } else if (clickedButton === colorButton) {
            if (currentMode !== "color") {
              currentMode = "color";
              coloringSubMode = "cell"; // Always start with 'cell' when entering color mode
            } else {
              // If already in color mode, just toggle the sub-mode
              coloringSubMode =
                coloringSubMode === "cell" ? "candidate" : "cell";
            }
          }

          // --- UI Update Logic (based on the new state) ---
          modeToggleButton.textContent =
            currentMode === "pencil" ? "Pencil" : "Number (Z)";

          if (currentMode === "color") {
            colorButton.textContent =
              coloringSubMode === "cell" ? "Color: Cell" : "Color: Cand";
          } else {
            colorButton.textContent = "Color (X)"; // Reset text if not in color mode
          }

          // --- Tip Display Logic ---
          let tip = "";
          if (currentMode === "concrete") {
            tip =
              "Tip: Click a filled cell (or press 'Enter') to highlight its number.";
          } else if (currentMode === "pencil") {
            tip = "Tip: Click a cell, then a digit to toggle a pencil mark.";
          } else if (currentMode === "color") {
            if (coloringSubMode === "cell") {
              tip =
                "Tip: Pick a color, then click a cell (or press 'C') to paint it.";
            } else {
              tip =
                "Tip: Pick a color, then click a cell (or press 'C') to select a candidate.";
            }
          }
          showMessage(tip, "gray");

          // Update active classes for all buttons
          modeToggleButton.classList.toggle(
            "active",
            currentMode === "concrete" || currentMode === "pencil"
          );
          colorButton.classList.toggle("active", currentMode === "color");

          // Update the number/color pad if the mode type changed
          const wasColor = previousMode === "color";
          const isColor = currentMode === "color";
          if (wasColor !== isColor) {
            updateControls();
            if (!isColor) {
              selectedColor = null; // Clear selected color when leaving color mode
            }
          }
          renderBoard();
        }

        function handleNumberPadClick(e) {
          const btn = e.target.closest("button");
          if (!btn) return;

          if (currentMode === "color") {
            selectedColor = btn.dataset.color;
            numberPad
              .querySelectorAll(".color-btn")
              .forEach((b) => b.classList.remove("selected"));
            btn.classList.add("selected");
            return;
          }

          const num = parseInt(btn.dataset.number);

          if (selectedCell.row !== null) {
            const { row, col } = selectedCell;
            const cellState = boardState[row][col];
            if (cellState.isGiven) return;

            let changeMade = false;
            if (currentMode === "concrete") {
              const oldValue = cellState.value;
              const newValue = oldValue === num ? 0 : num;
              if (oldValue !== newValue) {
                cellState.value = newValue;
                if (newValue !== 0) {
                  cellState.pencils.clear();
                  autoEliminatePencils(row, col, newValue);
                }
                changeMade = true;
              }
            } else {
              // pencil mode
              if (cellState.value === 0) {
                if (cellState.pencils.has(num)) {
                  cellState.pencils.delete(num);
                } else {
                  cellState.pencils.add(num);
                }
                changeMade = true;
              }
            }
            if (changeMade) {
              saveState();
              renderBoard();
              checkCompletion();
            } else {
              renderBoard();
            }
          }
        }

        function checkCompletion() {
          // Check if any cell is empty
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              if (boardState[r][c].value === 0) {
                return; // Not finished yet
              }
            }
          }

          // If no cells are empty, validate the board
          if (validateBoard()) {
            showMessage("Congratulations! You solved it!", "green");
            triggerSolveAnimation();
            stopTimer();
          }
        }

        function triggerSolveAnimation() {
          gridContainer.classList.add("is-solved");
          setTimeout(() => {
            gridContainer.classList.remove("is-solved");
          }, 2620); // Duration is roughly (80 * 20ms) + 1000ms
        }

        function showCandidatePopup(row, col) {
          candidateGrid.innerHTML = "";
          const cellState = boardState[row][col];
          if (cellState.pencils.size === 0) return;

          const orderA = [1, 2, 3, 4, 5, 6, 7, 8, 9];
          const orderB = [7, 8, 9, 4, 5, 6, 1, 2, 3];
          const currentOrder = candidatePopupFormat === "A" ? orderA : orderB;

          currentOrder.forEach((i) => {
            const btn = document.createElement("button");
            btn.textContent = i;
            btn.className =
              "p-3 border dark:border-gray-500 text-gray-800 dark:text-gray-200 bg-gray-50 dark:bg-slate-700 rounded-md";
            if (cellState.pencils.has(i)) {
              btn.classList.add("hover:bg-gray-200", "dark:hover:bg-slate-600");
              if (cellState.pencilColors.has(i)) {
                btn.style.backgroundColor = cellState.pencilColors.get(i);
              }
              btn.onclick = () => {
                const currentColor = cellState.pencilColors.get(i);
                if (currentColor === selectedColor) {
                  cellState.pencilColors.delete(i);
                } else {
                  cellState.pencilColors.set(i, selectedColor);
                }
                saveState();
                candidateModal.classList.add("hidden");
                renderBoard();
              };
            } else {
              btn.disabled = true;
              btn.classList.add("opacity-25");
            }
            candidateGrid.appendChild(btn);
          });
          candidateModal.classList.remove("hidden");
          candidateModal.classList.add("flex");
        }

        function clearAllColors() {
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              boardState[r][c].cellColor = null;
              boardState[r][c].pencilColors.clear();
            }
          }
          saveState();
          renderBoard();
          showMessage("All colors cleared.", "gray");
        }

        function autoEliminatePencils(row, col, num) {
          // Eliminate from row
          for (let c = 0; c < 9; c++) {
            boardState[row][c].pencils.delete(num);
          }
          // Eliminate from column
          for (let r = 0; r < 9; r++) {
            boardState[r][col].pencils.delete(num);
          }
          // Eliminate from 3x3 box
          const boxRowStart = Math.floor(row / 3) * 3;
          const boxColStart = Math.floor(col / 3) * 3;
          for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
              boardState[boxRowStart + r][boxColStart + c].pencils.delete(num);
            }
          }
        }

        function autoPencil() {
          const board = boardState.map((row) => row.map((cell) => cell.value));
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              const cellState = boardState[r][c];
              if (cellState.value === 0) {
                cellState.pencils.clear();
                for (let num = 1; num <= 9; num++) {
                  if (isValid(board, r, c, num)) {
                    cellState.pencils.add(num);
                  }
                }
              }
            }
          }
          saveState();
          renderBoard();
          showMessage("Auto-Pencil complete!", "green");
        }

        function loadPuzzle(puzzleString, puzzleData = null) {
          if (puzzleString.length !== 81 || !/^[0-9\.]+$/.test(puzzleString)) {
            showMessage("Error: Invalid puzzle string.", "red");
            addSudokuCoachLink(null); // Also clear the link on error
            return;
          }
          initBoardState();
          for (let i = 0; i < 81; i++) {
            const row = Math.floor(i / 9);
            const col = i % 9;
            if (puzzleString[i] !== "." && puzzleString[i] !== "0") {
              boardState[row][col].value = parseInt(puzzleString[i]);
              boardState[row][col].isGiven = true;
            }
          }
          selectedCell = { row: null, col: null };
          history = [];
          historyIndex = -1;

          if (puzzleData) {
            // Format the display text with both number and word
            puzzleLevelEl.textContent = `Lv. ${puzzleData.level} (${
              difficultyWords[puzzleData.level]
            })`;
            puzzleScoreEl.textContent = `Score: ${puzzleData.score}`;
            puzzleInfoContainer.classList.remove("hidden");
          } else {
            puzzleLevelEl.textContent = "";
            puzzleScoreEl.textContent = "";
            puzzleInfoContainer.classList.add("hidden");
          }
          saveState();
          renderBoard();
          addSudokuCoachLink(puzzleString);
          if (!puzzleData) showMessage("Custom puzzle loaded!", "green");
          startTimer();
        }

        function clearUserBoard() {
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              if (!boardState[r][c].isGiven) {
                boardState[r][c].value = 0;
                boardState[r][c].pencils.clear();
              }
            }
          }
          saveState();
          renderBoard();
          showMessage("Board cleared.", "gray");
          // startTimer();
        }

        function validateBoard() {
          const board = boardState.map((row) => row.map((cell) => cell.value));
          const cells = gridContainer.querySelectorAll(".sudoku-cell");
          let allValid = true;

          cells.forEach((cell) => cell.classList.remove("invalid"));

          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              const num = board[r][c];
              if (num === 0 || boardState[r][c].isGiven) continue;

              board[r][c] = 0; // Temporarily remove to check
              if (!isValid(board, r, c, num)) {
                cells[r * 9 + c].classList.add("invalid");
                allValid = false;
              }
              board[r][c] = num; // Restore
            }
          }
          return allValid;
        }

        function solve() {
          if (!validateBoard()) {
            showMessage(
              "Conflicts on board! Correct red cells before solving.",
              "red"
            );
            return;
          }

          let board = boardState.map((row) => row.map((cell) => cell.value));
          if (solveSudoku(board)) {
            for (let r = 0; r < 9; r++) {
              for (let c = 0; c < 9; c++) {
                boardState[r][c].value = board[r][c];
                boardState[r][c].pencils.clear();
              }
            }
            saveState();
            renderBoard();

            showMessage("Puzzle Solved!", "green");
            triggerSolveAnimation();
            updateButtonStates();
            stopTimer();
          } else {
            showMessage(
              "This puzzle is unsolvable from the current state. Revise the filled numbers.",
              "red"
            );
          }
        }

        function findEmpty(board) {
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              if (board[r][c] === 0) return [r, c];
            }
          }
          return null;
        }

        function isValid(board, row, col, num) {
          for (let c = 0; c < 9; c++) {
            if (board[row][c] === num) return false;
          }
          for (let r = 0; r < 9; r++) {
            if (board[r][col] === num) return false;
          }
          const boxRowStart = Math.floor(row / 3) * 3;
          const boxColStart = Math.floor(col / 3) * 3;
          for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
              if (board[boxRowStart + r][boxColStart + c] === num) return false;
            }
          }
          return true;
        }

        function solveSudoku(board) {
          const find = findEmpty(board);
          if (!find) return true;
          const [row, col] = find;

          for (let num = 1; num <= 9; num++) {
            if (isValid(board, row, col, num)) {
              board[row][col] = num;
              if (solveSudoku(board)) return true;
              board[row][col] = 0;
            }
          }
          return false;
        }

        function showMessage(text, color) {
          messageArea.textContent = text;
          const colors = {
            red: "text-red-600",
            green: "text-green-600",
            gray: "text-gray-600",
          };
          messageArea.className = `text-center text-sm font-semibold h-5 ${
            colors[color] || "text-gray-600"
          }`;
        }

        // --- Timer Functions ---

        function startTimer() {
          stopTimer(); // Clear any existing timer before starting a new one
          startTime = Date.now();
          puzzleTimerEl.textContent = "00:00"; // Initial display
          timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
          if (timerInterval) clearInterval(timerInterval);
        }

        function updateTimer() {
          const elapsedMs = Date.now() - startTime;
          const totalSeconds = Math.floor(elapsedMs / 1000);
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;

          const formattedSeconds = String(seconds).padStart(2, "0");
          const formattedMinutes = String(minutes).padStart(2, "0");

          if (hours > 0) {
            const formattedHours = String(hours).padStart(2, "0");
            puzzleTimerEl.textContent = `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
          } else {
            puzzleTimerEl.textContent = `${formattedMinutes}:${formattedSeconds}`;
          }
        }

        // --- History Functions ---

        function cloneBoardState(state) {
          return state.map((row) =>
            row.map((cell) => ({
              value: cell.value,
              isGiven: cell.isGiven,
              pencils: new Set(cell.pencils),
              cellColor: cell.cellColor,
              pencilColors: new Map(cell.pencilColors),
            }))
          );
        }

        function saveState() {
          history = history.slice(0, historyIndex + 1);
          history.push(cloneBoardState(boardState));
          historyIndex++;
          updateUndoRedoButtons();
        }

        function undo() {
          if (historyIndex > 0) {
            historyIndex--;
            boardState = cloneBoardState(history[historyIndex]);
            renderBoard();
            updateUndoRedoButtons();
          }
        }

        function redo() {
          if (historyIndex < history.length - 1) {
            historyIndex++;
            boardState = cloneBoardState(history[historyIndex]);
            renderBoard();
            updateUndoRedoButtons();
          }
        }

        function updateUndoRedoButtons() {
          undoBtn.disabled = historyIndex <= 0;
          redoBtn.disabled = historyIndex >= history.length - 1;
        }

        initialize();
      });
    </script>
  </body>
</html>
